<!DOCTYPE html>
<html lang="en">
<head>
  <title>rad - general purpose, typed build tools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/themes/prism.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/themes/prism-okaidia.min.css" rel="stylesheet" />
<style>
/**
 * override okaidia bogus operator
 */
.token.operator {
 background-color: transparent !important;
}

/* page */
@import url(https://fonts.googleapis.com/css?family=Open+Sans:800);
html, body {
  height: 100%;
  margin: 0;
  width: 100vw;
}
a, a:visited {color:#2196f3;} /* Visited link    */
table {
  display: block;
  overflow-x: scroll;
  border: 0.1px dashed #ffffff1a;
  padding: 8px;
}
td {
  border: 0.1px dashed #ffffff1a;
  padding: 8px;
}

/* hero */
.baby-rad {
  transition: all 5s;
}
svg text {
  fill: white;
  stroke-width: 1;
  stroke: beige;
}

/* content */
body {
  font-family: sans-serif;
  background-color: #303030;
  color: white;
}
div.content {
  margin: auto;
  max-width: 800px;
  padding: 1em;
}
svg {
  background: #303030;
  font: 5em/1 Open Sans, Impact;
  text-transform: uppercase;
  margin: 0;
  width: 100%;
  height: 300px;
}
#big_baby {
  cursor: pointer;
}
</style>
</head>
<body>
<svg id=radness viewBox="0 0 800 300">
  <symbol id="repeatme">
    <text text-anchor="middle" x="0" y="0" dx='1em' dy="1em">RAD</text>
  </symbol>
  <g id="repeats" />
  <use class="text" xlink:href="#big_baby" />
  <symbol id="big_baby">
    <text text-anchor="middle" x="85%" y="80%" dy=".35em">RAD</text>
  </symbol>
</svg>
<div class='content'>
  <h1 id="rad-üíØ">rad üíØ</h1>
<p>a general purpose build tool.</p>
<p>statically typed, batteries included. command tasks, function tasks, and make-style tasks supported.</p>
<table>
<thead>
<tr>
<th>branch</th>
<th>status-badge</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td><img src="https://github.com/cdaringe/rad/workflows/master/badge.svg" alt="master"></td>
</tr>
<tr>
<td>next</td>
<td><img src="https://github.com/cdaringe/rad/workflows/next/badge.svg" alt="next"></td>
</tr>
</tbody></table>
<p>jump to:</p>
<ol>
<li><a href="#usage">usage</a></li>
<li><a href="#install">install</a></li>
<li><a href="#what-is-it">what</a></li>
<li><a href="https://cdaringe.github.io/rad/#why-not-my-favorite-build-tool">why not <code>&lt;my-favorite-build-tool&gt;</code>?</a></li>
<li><a href="https://cdaringe.github.io/rad/#manual">manual</a></li>
</ol>
<h2 id="usage">usage</h2>
<p><code>$ rad &lt;task-name&gt; [--help]</code></p>
<pre><code class="language-ts">// rad.ts
import { Tasks } from &quot;https://raw.githubusercontent.com/cdaringe/rad/master/src/mod.ts&quot;;

// command tasks
const format = `prettier --write`
const test = `deno test`

// function tasks
const compile = {
  dependsOn: [format],
  fn({ sh, ...toolkit }) =&gt; sh(&#39;tsc&#39;)
}

// make-style tasks
const transpile = {
  target: &quot;phony&quot;,
  prereqs: [&quot;p1&quot;, &quot;p2&quot;],
  async onMake({ logger }, { changedPrereqs /*, prereqs */}) {
    for await (const req of changedPrereqs) {
      logger.info(`req: ${req.filename} ${JSON.stringify(req.info)}`);
    }
  },
}

export const tasks: Tasks = {
  compile,
  format,
  test
}</code></pre>
<h2 id="install">install</h2>
<p>there are a few formal ways to use <code>rad</code>. regardless of the route you choose,
know that all strategies support using pinned versions, adherent to semver.
see the <a href="https://github.com/cdaringe/rad/releases">releases page</a>.</p>
<table>
<thead>
<tr>
<th>usage</th>
<th>install-method</th>
<th>install-steps</th>
</tr>
</thead>
<tbody><tr>
<td>cli</td>
<td><code>deno</code></td>
<td><code>deno install rad https://github.com/cdaringe/rad/blob/master/src/bin.ts</code></td>
</tr>
<tr>
<td>cli</td>
<td><code>docker</code></td>
<td><code>docker pull cdaringe/rad</code> <sup>1</sup></td>
</tr>
<tr>
<td>cli</td>
<td><code>curl+sh</code></td>
<td>`curl <todo>.sh</td>
</tr>
<tr>
<td>library</td>
<td><code>deno</code></td>
<td><code>import * as rad from https://github.com/cdaringe/rad/blob/master/src/mod.ts</code></td>
</tr>
</tbody></table>
<p><sup>1</sup>For docker users, consider making a nice shell alias</p>
<pre><code class="language-sh"># shell profile, e.g. .bash_profile
function rad() {
  docker run --rm -v $PWD:/rad cdaringe/rad &quot;$@&quot;;
}</code></pre>
<h2 id="what-is-it">what is it</h2>
<p>a build tool! it competes with make, npm-scripts, bazel, gradle, ant, gulp, or any of the
other many tools out there!</p>
<p><code>rad</code> offers:</p>
<ul>
<li>simple, programmable task interfaces</li>
<li>easy to understand, declarative build steps</li>
<li>type-checked tasks</li>
<li>productive toolkit API for nuanced tasks that benefit from progamming. see <a href="#toolkit">toolkit</a><!-- @todo write toolkit docs--></li>
<li>bottom-up, <code>make</code>-style build targets<ul>
<li>fast builds, skip redundant work when inputs haven&#39;t changed</li>
</ul>
</li>
<li>cli mode, or library mode</li>
<li>portability. build automation for <em>any</em> language or project, in many environments (*limited to <em>Deno</em> target architectures, for the time being. long term, we may package this in <code>Rust</code>)</li>
<li>great UX</li>
<li>no quirky DSLs (<code>make</code>, <code>gradle</code>, and friends üò¢). <strong>your build is code</strong>--tasks are typescript &amp; are indeed type-checked!</li>
<li>debuggability. üêõ inspect your data, tasks, or even <em>rad</em> itself</li>
<li>a real scripting language--<strong>not</strong> <code>bash/sh</code>! shell languages are great for running other programs, not for plumbing data</li>
</ul>
<p>see <a href="https://cdaringe.github.io/rad/#why-not-my-favorite-build-tool">why not <code>&lt;my-favorite-build-tool&gt;</code>?</a></p>

<h2 id="toolkit">toolkit</h2>
<p><a href="https://github.com/cdaringe/rad/blob/">https://github.com/cdaringe/rad/blob/</a>
f27c5d5f7cd8c40b1cb94b1f659c1b3768c7dc00/src/Task.ts#L33-L42</p>

<h1 id="why-not-my-favorite-build-tool">why not <code>&lt;my-favorite-build-tool&gt;</code>?</h1>
<p>your build tool is probably great. keep using it if you love it.
the intent here it not to dump on anyone or any tool, but articulate feature gaps.</p>
<table>
<thead>
<tr>
<th>tool</th>
<th>DSL-less</th>
<th>static types</th>
<th>standalone</th>
<th>polyglot</th>
<th>incremental</th>
<th>debuggable</th>
<th>beautiful</th>
<th>dependency manager</th>
</tr>
</thead>
<tbody><tr>
<td>bazel</td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>gradle</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
</tr>
<tr>
<td>gulp/grunt</td>
<td>‚úì</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td></td>
</tr>
<tr>
<td>make</td>
<td></td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>npm-scripts</td>
<td>‚úì</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>‚úì</td>
</tr>
<tr>
<td>rad</td>
<td>‚úì</td>
<td>‚úì</td>
<td></td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td>‚úì</td>
<td></td>
</tr>
</tbody></table>
<p>ant, scons, ninja, etc were omitted. haven&#39;t used &#39;em!</p>
<p>here are some genuine, not-trying-be-rude-opinions.</p>
<ul>
<li>bazel is complex. maybe you need that complexity. ü§∑üèª‚Äç‚ôÄÔ∏è</li>
<li>gradle is full of magic and is often hard to reason about <em>where</em> behavior comes from.</li>
<li>gulp/grunt have no make-style tasks, are generally node only, comparatively slow, &amp; stringly typed in various places.</li>
<li>make is great, but has a lame DSL and is coupled to a poor scripting language</li>
<li>npm-scripts are simple, but suffer releated drawbacks to gulp/grunt.</li>
</ul>
<p>loose typing, unneeded/obsolete DSLs, lack of great static analysis, and <em>other</em> gaps
leave room for improvement in this space.</p>

<h2 id="manual">manual</h2>
<p>your guide to <code>rad</code>!</p>
<h3 id="understanding-rad">understanding rad</h3>
<ul>
<li><code>rad</code> is written in typescript and runs on <a href="https://deno.land/">deno</a></li>
<li>you write tasks, then ask <code>rad</code> to run them</li>
<li><code>rad</code> reads your radfile (i.e. <code>rad.ts</code>), compiles &amp; type checks it, then runs it through its task graph executor</li>
</ul>
<p>ü§Ø</p>
<h3 id="getting-started">getting started</h3>
<p>the first step to using rad is installation.
please see the <a href="#install">install</a> section for specifics.</p>
<p>the cli also has a decent help page. once you&#39;ve installed rad, try running
<code>rad --help</code>, just to grow acquainted with some of the options you may expect
down the road.</p>
<p>next up, creating a radfile!</p>
<h4 id="setting-up-radts">setting up rad.ts</h4>
<p>to create a new radfile (<code>rad.ts</code>), run the following command:</p>
<p><code>$ rad -l info --init</code></p>
<p>rad.ts should have <em>two</em> key traits:</p>
<ul>
<li>an <code>import { Task, Tasks } from &#39;https://path/to/rad/src/mod.ts</code> statment</li>
<li>an <code>export const tasks: Tasks = {...}</code> statement</li>
</ul>
<p>tasks are named in <code>rad.ts</code> strictly by their <em>key</em> in the <code>tasks</code> object.</p>
<pre><code class="language-ts">export const tasks: Tasks = {
  meet: /* omitted task */,
  greet: /* omitted task */
}</code></pre>
<p>the above file has exactly two tasks--<code>meet</code> and <code>greet</code>! simple!</p>
<p><code>rad</code> will look in the working directory for your radfile by default.
if you so choose, you are welcome place it elsewhere, and tell rad where to find it using the
<code>-r/--radfile</code> flag. next up, let&#39;s define those tasks.</p>
<h3 id="tasks">tasks</h3>
<p>tasks can take a couple of different forms. generally, you can simply refer to
the <code>Task</code> type in your radfile and get cracking. let&#39;s write a few <em>tasks</em> of each type.</p>
<h4 id="command-tasks">command tasks</h4>
<p>command tasks are the simplest tasks. they are shell commands for rad to execute:</p>
<pre><code class="language-ts">// rad.ts
import { Task, Tasks } from &#39;url/to/rad/mod.ts&#39;

const compile: Task = `clang file.c`
const greet: Task = `echo &quot;hello, world!&quot;`

export const tasks: Tasks = { compile, greet }</code></pre>
<p>command tasks are the only <code>&#39;string&#39;</code> inferface tasks. the associated command
will get executed by <code>rad</code> in a child process, a la <code>&lt;your-shell&gt; -c &#39;&lt;your-cmd&gt;&#39;</code>,
e.g. <code>bash -c &#39;echo &quot;hello, world!&quot;&#39;</code>.</p>
<h4 id="function-tasks">function tasks</h4>
<p>function tasks are the most capable of all tasks. all other task types internally get
transformed into a function task. to use function tasks, create a POJO with a
<code>fn</code> key and function value. <code>fn</code> brings one argument--<a href="#toolkit"><code>toolkit</code></a>--that
offers a nice suite of batteries for your convenience. ‚ö°Ô∏è</p>
<pre><code class="language-ts">// rad.ts
import { Task, Tasks } from &#39;url/to/rad/mod.ts&#39;;

const build: Task = {
  fn: async toolkit =&gt; {
    const { logger, sh } = toolkit;
    await sh(`clang hello.c -o hello`);
    logger.info(`compile ok, asserting executable`);
    await sh(`./hello`); // stdout: Hello, world!
    logger.info(&quot;binary ok&quot;);
  },
};

export const tasks: Tasks = { build };</code></pre>
<p>this is a <em>pretty</em> basic function task. when you get to the <a href="#toolkit"><code>toolkit</code></a>
section, you will see the other <em>interesting</em> utilities provided to do great
things with!</p>
<h4 id="make-tasks">make tasks</h4>
<p>make tasks are in honor of <a href="https://www.gnu.org/software/make/">gnu make</a>. our
make task is not nearly feature complete with a proper make task--but it does have one essential
core parity--providing an api to access <em>only files that have changed</em> since the
last task run. more speficially, if offers an api to access only files that have been
modified <em>since</em> the <code>target</code> has been last modified.
of course, it also exposes <em>all</em> files specified by your prerequisites
as well. one <em>essential</em> difference between our make task and proper-make tasks
is that your <code>onMake</code> function will <em>still run</em> even if
no files have changed since the make <code>target</code> has changed--it is up to you to
<em>do nothing</em> in the task handler if no work is warranted.</p>
<p>let&#39;s take inspiration from a make task in our very own source project--the build
for this website. here&#39;s a simplified version:</p>
<pre><code class="language-ts">// rad.ts
import { Task, Tasks } from &#39;url/to/rad/mod.ts&#39;

const site: Task = {
  target: &quot;public/index.html&quot;,
  prereqs: [&quot;assets/site/**/*.{md}&quot;], // globs only
  onMake: async (
    /* toolkit api -- see #toolkit */
    { fs, logger },
    /* make task api */
    {
      getPrereqFilenames, // Promise&lt;string&gt;
      /**
       * prereqs, // AsyncIterable&lt;WalkInfo&gt;
       * changedPrereqs, // AsyncIterable&lt;WalkInfo&gt;
       * getChangedPrereqFilenames, // Promise&lt;string&gt;
       */
    }) =&gt; {
    await fs.mkdirp(&quot;public&quot;);
    logger.info(&quot;collecting prereq filenames&quot;);
    const filenames = await getPrereqFilenames();
    const html = await Promise.all(filenames.map(
      filename =&gt; fs.readFile(filename).then(
        markdown =&gt; marked(markdown)
      )
    )).then(htmlSnippets =&gt; htmlSnippets.join(&#39;\n&#39;));
    await fs.writeFile(&quot;./public/index.html&quot;, html);
  },
};</code></pre>
<p>if you have <strong>many</strong> prereqs, you should probably consider using
the <code>AsyncIterator</code> implementations referenced above so as to not eat
all of your memory üòÄ.</p>
<p>check out the type definitions for more!</p>
<h3 id="task-depedencies">task depedencies</h3>
<p>all task types, except command style tasks, accept an optional <code>dependsOn</code> array.
<code>dependsOn</code> is an array of task references. task references must be
<strong>actual task references</strong>--string based task lookups are not supported, intentionally.</p>
<pre><code class="language-ts">// rad.ts
import { Task, Tasks } from &#39;url/to/rad/mod.ts&#39;

const install: Task = {
  target: &#39;node_modules&#39;,
  prereqs: [&#39;package.json&#39;],
  onMake: async ({ sh }, { getChangedPrereqFilenames }) =&gt; {
    const changed = await getChangedPrereqFilenames()
    if (changed.length) await sh(`npm ci --verbose`)
  }
}
const lint: Task = {
  dependsOn: [install],
  fn: ({ sh }) =&gt; sh(`npm run lint`)
}
const test: Task = {
  dependsOn: [install],
  fn: ({ sh }) =&gt; sh(`npm test`)
}

const ci: Task = {
  dependsOn: [lint, test],
};

export const tasks: Tasks = {
  ci,
  install,
  lint,
  test,
}</code></pre>
<p>sweet! now, our <code>ci</code> task should depend on lint &amp; test tasks, of which lint
You can see <code>dependsOn</code> at work by using <code>--print-graph</code>:</p>
<pre><code class="language-sh">$ rad ci --print-graph
‚îî‚îÄ ci
   ‚îú‚îÄ lint
   ‚îÇ  ‚îî‚îÄ install
   ‚îî‚îÄ test
      ‚îî‚îÄ install</code></pre>
<h3 id="toolkit">toolkit</h3>
<p>The <code>toolkit</code> is the first argument to <code>function</code> based tasks!</p>
<p>It has the following type!</p>
<pre><code class="language-ts">export type Toolkit = {
  Deno: typeof Deno;
  fs: fs.FsUtil;
  sh: typeof sh;
  dependentResults: any[];
  logger: Logger;
  path: typeof path;
  task: RadTask;
  iter: typeof iter;
};</code></pre>
<p>well that&#39;s not <em>super</em> helpful! let&#39;s study each these keys, one-by-one:</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td><code>Deno</code></td>
<td>see the <a href="https://doc.deno.land/https/github.com/denoland/deno/releases/latest/download/lib.deno.d.ts">deno api docs</a></td>
</tr>
<tr>
<td><code>fs</code></td>
<td>a few sugar methods, <code>{ readFile, writeFile, mkdirp }</code> that work on strings, vs buffers, and assume utf8 for shorthand</td>
</tr>
<tr>
<td><code>sh</code></td>
<td>execute a shell command. see the command task section above!</td>
</tr>
<tr>
<td><code>dependentResults</code></td>
<td>results of <code>dependsOn</code> tasks. currently these are untyped. getting type inference here is tricky. PRs welcome!</td>
</tr>
<tr>
<td><code>logger</code></td>
<td>the <code>rad</code> logger! a standard <code>Deno</code> logger with the commonplace log-level methods (e.g. <code>.info(...)</code>, <code>.debug(...)</code>, etc). see <a href="https://github.com/cdaringe/rad/blob/master/src/logger.ts">the source</a></td>
</tr>
<tr>
<td><code>path</code></td>
<td>a direct reference to <a href="https://deno.land/std/node/path.ts">deno node path</a>. this API is likely to change if Deno implements a full, proper path module</td>
</tr>
<tr>
<td><code>task</code></td>
<td>a reference to the internal <code>RadTask</code></td>
</tr>
<tr>
<td><code>iter</code></td>
<td><code>AsyncIterable</code> utility functions</td>
</tr>
</tbody></table>

</div>
<script>
  function paintBabies () {
    let max_rads = 50
    const [w, h] = [ 800, 300 ]
    const center = [w/2, h/2]
    var group = document.getElementById("repeats")
    const xforms = []
    const getTranslateProposal = () => [(Math.random() * w *.85), (h * Math.random())]
    const distance = ([a,b], [x, y]) => Math.sqrt(
      Math.pow(a - x, 2) + Math.pow(b - y, 2)
    )
    const walk = ([a,b], [stepX, stepY] = [10, 30]) => [
      a + ((Math.random()) + stepX) * (Math.random() > 0.5 ? 1 : -1),
      b + ((1 + Math.random()) + stepY) * (Math.random() > 0.5 ? 1 : -1),
    ]
    let i = max_rads
    while (i) {
      let translate = getTranslateProposal()
      while (distance(translate, [700, 280]) < 190) translate = walk(translate)
      xforms.push({
        translate,
        rotate: [360 * Math.random()],
      })
      --i
    }
    const getTransformString = ({ translate, rotate }) => `translate(${translate.join(' ')}) rotate(${rotate.join(' ')}) scale(0.5)`
    if (group.innerHTML) {
      var babies = Array.from(group.children)
      xforms.forEach((xform, i) => { babies[i].setAttribute('transform', getTransformString(xform)) })
    } else {
     group.innerHTML= xforms.map((xform, i) => `
      <use id='baby_${i}' class='text baby-rad' xlink:href="#repeatme"
        transform="${getTransformString(xform)}"
      />
    `).join('')
    }
  }
  paintBabies()
  setTimeout(() => {
    window.requestAnimationFrame(paintBabies)
  }, 500) // gimme one eager animation ;)
  setInterval(paintBabies, 60000)
  document.getElementById('big_baby').addEventListener('click', paintBabies)
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
